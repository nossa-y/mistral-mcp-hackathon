version: 0.2

env:
  variables:
    # Default to Python runtime if not specified
    RUNTIME: python3.13
    # Repository URI will be provided by CodeBuild environment
    PROJECT_BUILD_IMAGES_REPOSITORY_URI: ""
    # Source version for tagging
    RESOLVED_SOURCE_VERSION: ""
    # Default build arguments
    BUILD_ARG_INSTALL_COMMAND: ""
    BUILD_ARG_BUILD_COMMAND: ""
    BUILD_ARG_BUILD_OUTPUT_DIR: ""
    BUILD_ARG_START_COMMAND: ""

phases:
  pre_build:
    commands:
      # Set source directory based on environment
      - export SRC_DIR="$CODEBUILD_SRC_DIR/$SOURCE_REPOSITORY"
      # Clone repository if source repository is specified
      - |
        if [ -n "$SOURCE_REPOSITORY" ] && [ -n "$SOURCE_BRANCH" ] && [ -n "$SOURCE_REPOSITORY_CREDENTIALS" ]; then
          git clone --single-branch --branch $SOURCE_BRANCH https://x-access-token:$SOURCE_REPOSITORY_CREDENTIALS@$SOURCE_REPOSITORY.git $SRC_DIR
        else
          export SRC_DIR="$CODEBUILD_SRC_DIR"
        fi
      # Get resolved source version
      - export RESOLVED_SOURCE_VERSION=$(git -C $SRC_DIR rev-parse HEAD)
      # ECR login
      - aws ecr get-login-password | docker login --username AWS --password-stdin $PROJECT_BUILD_IMAGES_REPOSITORY_URI
      # Copy handler files if they exist
      - |
        if [ -n "$CODEBUILD_SRC_DIR_HANDLERS" ]; then
          cp -r $CODEBUILD_SRC_DIR_HANDLERS $SRC_DIR/alpic
        fi
      # Ensure our Dockerfile is available where AWS expects it
      - |
        if [ -n "$CODEBUILD_SRC_DIR_DOCKERFILES" ]; then
          echo "Using AWS-provided Dockerfile location: $CODEBUILD_SRC_DIR_DOCKERFILES"
          # Copy our Dockerfile to the expected location if it doesn't exist
          if [ ! -f "$CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME" ]; then
            echo "Copying our Dockerfile to AWS expected location"
            mkdir -p "$CODEBUILD_SRC_DIR_DOCKERFILES"
            cp "$SRC_DIR/dockerfiles/$RUNTIME" "$CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME"
          fi
        else
          echo "No AWS Dockerfile directory specified, using local dockerfiles"
          export CODEBUILD_SRC_DIR_DOCKERFILES="$SRC_DIR/dockerfiles"
        fi
      # Detect MCP transport type
      - |
        cd $SRC_DIR
        export TRANSPORT_TYPE=$( (grep -r "import.*from ['\"]@modelcontextprotocol/sdk/server/\(stdio\|sse\|streamableHttp\)[.'\"]" --include="*.ts" . | grep -o -E "(stdio|sse|streamableHttp)" | head -1 | tr '[:upper:]' '[:lower:]';grep -r "mcp.run(.*transport=['\"]\(stdio\|sse\|streamable-http\|http\)['\"]" --include="*.py" . | grep -o -E "(stdio|sse|streamable-http|http)" | head -1;grep -r "mcp.run(" --include="*.py" . | head -1 | sed 's/.*/stdio/') | head -1)
      - |
        if [ -z "$TRANSPORT_TYPE" ]; then
          echo "Error: No MCP transport found"; exit 1
        else
          echo "MCP transport: $TRANSPORT_TYPE"
        fi
      # Verify required files exist before building
      - |
        echo "Verifying build dependencies in $SRC_DIR"
        if [ ! -f "$SRC_DIR/uv.lock" ]; then
          echo "ERROR: uv.lock not found at $SRC_DIR/uv.lock"
          exit 1
        fi
        if [ ! -f "$SRC_DIR/pyproject.toml" ]; then
          echo "ERROR: pyproject.toml not found at $SRC_DIR/pyproject.toml"
          exit 1
        fi
        if [ ! -f "$CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME" ]; then
          echo "ERROR: Dockerfile not found at $CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME"
          exit 1
        fi
        if [ ! -d "$SRC_DIR/mcp_servers" ]; then
          echo "ERROR: mcp_servers directory not found at $SRC_DIR/mcp_servers"
          exit 1
        fi
        if [ ! -d "$SRC_DIR/shared" ]; then
          echo "ERROR: shared directory not found at $SRC_DIR/shared"
          exit 1
        fi
        if [ ! -f "$SRC_DIR/lambda_handler.py" ]; then
          echo "ERROR: lambda_handler.py not found at $SRC_DIR/lambda_handler.py"
          exit 1
        fi
        echo "All required files verified"
        echo "Build context: $SRC_DIR"
        echo "Dockerfile: $CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME"
        ls -la "$SRC_DIR/" | head -10

  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image for runtime $RUNTIME with transport $TRANSPORT_TYPE...
      # Build the Docker image with all necessary build arguments
      - docker buildx build
          --provenance=false
          --platform linux/amd64
          --build-arg INSTALL_COMMAND="${BUILD_ARG_INSTALL_COMMAND}"
          --build-arg BUILD_COMMAND="${BUILD_ARG_BUILD_COMMAND}"
          --build-arg BUILD_OUTPUT_DIR="${BUILD_ARG_BUILD_OUTPUT_DIR}"
          --build-arg START_COMMAND="${BUILD_ARG_START_COMMAND}"
          --build-arg TRANSPORT_TYPE=$TRANSPORT_TYPE
          -t $PROJECT_BUILD_IMAGES_REPOSITORY_URI:$RESOLVED_SOURCE_VERSION
          -t $PROJECT_BUILD_IMAGES_REPOSITORY_URI:latest
          -f $CODEBUILD_SRC_DIR_DOCKERFILES/$RUNTIME
          $SRC_DIR

  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker images...
      # Push both tagged and latest images
      - docker push $PROJECT_BUILD_IMAGES_REPOSITORY_URI:$RESOLVED_SOURCE_VERSION
      - docker push $PROJECT_BUILD_IMAGES_REPOSITORY_URI:latest
      - echo Docker images pushed successfully

artifacts:
  files:
    - '**/*'
# Multi-stage Docker build for ColdOpen Coach MCP servers
# Based on AWS Lambda Python 3.13 runtime

# Stage 1: UV builder - get UV binary
FROM ghcr.io/astral-sh/uv:0.8.15 as uv

# Stage 2: Builder - create requirements and install dependencies
FROM public.ecr.aws/lambda/python:3.13 as builder

# Set working directory to the Lambda task root
WORKDIR ${LAMBDA_TASK_ROOT}

# Copy Python configuration files for dependency installation
# These paths are relative to the build context (repository root)
COPY uv.lock ./uv.lock
COPY pyproject.toml ./pyproject.toml

# Install dependencies to Lambda task root using UV
# Use UV from the uv stage and cache for faster builds
RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    uv export --frozen --no-emit-workspace --no-dev --no-editable -o requirements.txt && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

# Stage 3: Runner - final Lambda image
FROM public.ecr.aws/lambda/python:3.13 as runner

# Copy installed dependencies from builder
COPY --from=builder ${LAMBDA_TASK_ROOT} ${LAMBDA_TASK_ROOT}

# Copy application code
# These paths are relative to the build context (repository root)
COPY mcp_servers/ ${LAMBDA_TASK_ROOT}/mcp_servers/
COPY shared/ ${LAMBDA_TASK_ROOT}/shared/
COPY lambda_handler.py ${LAMBDA_TASK_ROOT}/

# Set the Lambda handler
# This will need to be customized based on which MCP server you're deploying
# Available handlers: lambda_handler.x_handler, lambda_handler.linkedin_handler
CMD ["lambda_handler.lambda_handler"]